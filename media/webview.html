<!DOCTYPE html>
<html style="height: 100%;">

<head>
    <meta charset="utf-8" />
    <title>Log Viewer</title>
</head>

<body style="height: 100%; margin: 0; display: flex; flex-direction: column; font-family: sans-serif;">

    <div style="padding: 3px; background: #2d2d2d; display: flex; align-items: center; gap: 12px;">
        <!-- å·¦åŠéƒ¨åˆ†ï¼šæœç´¢åŒºåŸŸ -->
        <div
            style="flex: 1; display: flex; align-items: center; background: #3a3a3a; border: 1px solid #555; border-radius: 6px; padding: 4px;">
            <div style="color: #4CAF50; font-weight: bold; font-size: 12px; margin-right: 8px; white-space: nowrap;">ğŸ”
                æœç´¢</div>
            <input id="search" type="text" placeholder="Search logs..."
                style="flex: 1; padding: 4px 6px; border: 1px solid #666; border-radius: 3px; background: #2a2a2a; color: white;" />

            <!-- å¿«é€Ÿæœç´¢æ ‡ç­¾ -->
            <div id="quickSearchLabels" style="display: flex; align-items: center; gap: 8px; margin-left: 8px;">
                <!-- åŠ¨æ€ç”Ÿæˆçš„å¿«é€Ÿæœç´¢æ ‡ç­¾å°†åœ¨è¿™é‡Œ -->
            </div>

            <button id="clearLogBtn"
                style="margin-left: 8px; padding: 3px 6px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">æ¸…é™¤æ—¥å¿—</button>
            <div id="status" style="color: white; margin-left: 6px; white-space: nowrap;"></div>
        </div>

        <!-- å³åŠéƒ¨åˆ†ï¼šGMæŒ‡ä»¤åŒºåŸŸ -->
        <div
            style="flex: 1; display: flex; align-items: center; background: #4a3a4a; border: 1px solid #665566; border-radius: 6px; padding: 4px;">
            <div style="color: #FF9800; font-weight: bold; font-size: 12px; margin-right: 8px; white-space: nowrap;">âš¡
                GMæŒ‡ä»¤</div>
            <input id="gmCommand" type="text" placeholder="è¯·è¾“å…¥GMæŒ‡ä»¤..."
                style="flex: 1; padding: 4px 6px; border: 1px solid #776677; border-radius: 3px; background: #3a2a3a; color: white;" />
        </div>
    </div>

    <pre id="log"
        style="flex: 1; background: #1e1e1e; color: white; margin: 0; padding: 10px; overflow: auto; white-space: pre-wrap;"></pre>

    <div id="matches"
        style="max-height: 100px; overflow-y: auto; background: #3a3a3a; color: #ccc; font-size: 12px; border: 1px solid #4CAF50; border-radius: 4px; padding: 4px; margin: 3px; white-space: nowrap; box-shadow: 0 1px 2px rgba(0,0,0,0.3);">
    </div>

    <script>
        // Webview ä¸»é€»è¾‘
        class LogViewer {
            constructor() {
                try {
                    this.vscode = acquireVsCodeApi();
                } catch (error) {
                    console.error('Failed to acquire VS Code API:', error);
                    // åˆ›å»ºä¸€ä¸ªæ¨¡æ‹Ÿçš„ vscode API ç”¨äºå¼€å‘æµ‹è¯•
                    this.vscode = {
                        postMessage: (msg) => console.log('Mock postMessage:', msg),
                        getState: () => null,
                        setState: (state) => console.log('Mock setState:', state)
                    };
                }

                this.currentLogLines = [];
                this.matchPositions = [];
                this.currentMatchIndex = -1;
                this.searchHistory = [];
                this.historyIndex = -1;
                this.searchTimeout = null;

                // å¿«é€Ÿæœç´¢å…³é”®è¯ - é»˜è®¤å€¼ï¼Œä¼šè¢«åç«¯é…ç½®è¦†ç›–
                this.quickSearchKeywords = ['all_succ', 'traceback'];

                // å¿«é€Ÿæœç´¢æ ‡ç­¾é¢œè‰²é…ç½® - å¯é…ç½®çš„é¢œè‰²æ•°ç»„
                this.quickSearchColors = ['#4CAF50', '#FF9800', '#E91E63', '#2196F3', '#9C27B0', '#FF5722'];

                // å¿«é€Ÿæœç´¢è®¡æ•°å™¨ - åŠ¨æ€ç”Ÿæˆ
                this.quickSearchCounts = new Map();
                this.quickSearchLabels = new Map(); // å­˜å‚¨æ ‡ç­¾å…ƒç´ çš„å¼•ç”¨
                this._isInitialized = false; // åˆå§‹åŒ–çŠ¶æ€æ ‡å¿—

                this.initElements();
                this.initEventListeners();
                this.hideMatchesDiv(); // åˆå§‹åŒ–æ—¶éšè—åŒ¹é…æ 
                this.restoreState();
                
                // å»¶è¿Ÿè¯·æ±‚åˆå§‹çŠ¶æ€å’Œå†å²è®°å½•ï¼Œç¡®ä¿å‰ç«¯å®Œå…¨åˆå§‹åŒ–
                setTimeout(() => {
                    this.requestInitialState();
                    this.requestHistory();
                }, 100);

                // åˆå§‹åŒ–å¿«é€Ÿæœç´¢è®¡æ•°å™¨ - å»¶è¿Ÿæ‰§è¡Œï¼Œé¿å…åˆå§‹åŒ–æ—¶çš„é‡å¤è°ƒç”¨
                setTimeout(() => {
                    this.checkAndUpdateQuickSearchCounts();
                }, 100);
            }

            initElements() {
                this.log = document.getElementById('log');
                this.search = document.getElementById('search');
                this.status = document.getElementById('status');
                this.matchesDiv = document.getElementById('matches');
                this.clearLogBtn = document.getElementById('clearLogBtn');

                // å¿«é€Ÿæœç´¢æ ‡ç­¾å®¹å™¨
                this.quickSearchLabelsContainer = document.getElementById('quickSearchLabels');
            }

            initEventListeners() {
                // æ¶ˆæ¯ç›‘å¬
                window.addEventListener('message', this.handleMessage.bind(this));

                // æ¸…é™¤æ—¥å¿—æŒ‰é’®
                this.clearLogBtn.addEventListener('click', this.clearLog.bind(this));

                // æœç´¢ç›¸å…³äº‹ä»¶
                this.search.addEventListener('keydown', this.handleSearchKeydown.bind(this));

                // åŒ¹é…é¡¹ç‚¹å‡»äº‹ä»¶å§”æ‰˜
                this.matchesDiv.addEventListener('click', this.handleMatchesDivClick.bind(this));

                // å¿«é€Ÿæœç´¢æ ‡ç­¾ç‚¹å‡»äº‹ä»¶å§”æ‰˜
                this.quickSearchLabelsContainer.addEventListener('click', this.handleQuickSearchClick.bind(this));

                // å¿«é€Ÿæœç´¢æ ‡ç­¾ç‚¹å‡»äº‹ä»¶å°†é€šè¿‡äº‹ä»¶å§”æ‰˜å¤„ç†

                // å®šæœŸä¿å­˜çŠ¶æ€
                setInterval(() => this.persistState(), 1000);
            }

            handleMessage(event) {
                const { type, lines, history, payload, targetLineIndex, colors } = event.data;

                switch (type) {
                    case 'history':
                        this.handleHistory(history);
                        break;
                    case 'restorePanelState':
                        this.handleRestorePanelState(payload);
                        break;
                    case 'log':
                        this.handleLog(lines, targetLineIndex);
                        break;
                    case 'searchResult':
                        this.handleSearchResult(payload);
                        break;
                    case 'updateQuickSearchCounts':
                        this.handleUpdateQuickSearchCounts(payload, colors);
                        break;
                    case 'updateQuickSearchColors':
                        this.updateQuickSearchColors(payload);
                        break;
                }
            }

            handleHistory(history) {
                console.log('æ”¶åˆ°å†å²è®°å½•:', history);
                if (Array.isArray(history)) {
                    this.searchHistory = [...history];
                    this.historyIndex = this.searchHistory.length;
                    console.log('å†å²è®°å½•å·²åŠ è½½ï¼Œå…±', this.searchHistory.length, 'æ¡');
                    
                    // å¦‚æœæœ‰å†å²è®°å½•ï¼Œæ¢å¤æœ€åä¸€ä¸ªæœç´¢æ–‡æœ¬åˆ°æœç´¢æ¡†
                    if (this.searchHistory.length > 0) {
                        const lastSearchText = this.searchHistory[this.searchHistory.length - 1];
                        if (lastSearchText && lastSearchText.trim()) {
                            this.search.value = lastSearchText;
                            console.log('æ¢å¤æœç´¢æ–‡æœ¬:', lastSearchText);
                        }
                    }
                } else {
                    console.warn('å†å²è®°å½•æ ¼å¼é”™è¯¯:', history);
                    this.searchHistory = [];
                    this.historyIndex = 0;
                }
            }

            handleRestorePanelState(payload) {
                console.log('æ¢å¤é¢æ¿çŠ¶æ€:', payload);
                if (payload.searchText) {
                    this.search.value = payload.searchText;
                    this.currentMatchIndex = payload.matchIndex || -1;
                    
                    // ç¡®ä¿æœç´¢æ–‡æœ¬ä¹Ÿè¢«æ·»åŠ åˆ°å†å²è®°å½•ä¸­
                    if (payload.searchText.trim() && !this.searchHistory.includes(payload.searchText)) {
                        this.searchHistory.push(payload.searchText);
                        this.historyIndex = this.searchHistory.length;
                        console.log('æ·»åŠ æœç´¢æ–‡æœ¬åˆ°å†å²è®°å½•:', payload.searchText);
                    }
                    
                    // å»¶è¿Ÿæ‰§è¡Œæœç´¢ï¼Œç¡®ä¿çŠ¶æ€å·²å®Œå…¨æ¢å¤
                    setTimeout(() => {
                        this.applySearch(this.search.value);
                    }, 100);
                } else {
                    this.hideMatchesDiv();
                }
                if (payload.scrollTop !== undefined) {
                    setTimeout(() => { this.log.scrollTop = payload.scrollTop; }, 100);
                }
            }

            handleLog(lines, targetLineIndex) {
                this.currentLogLines = lines || [];

                // æ›´æ–°å¿«é€Ÿæœç´¢è®¡æ•°å™¨ - åªåœ¨æœ‰å®é™…æ—¥å¿—æ•°æ®ä¸”ä¸æ˜¯æœç´¢è§†å›¾æ—¶æ›´æ–°
                // é¿å…åœ¨æœç´¢è§†å›¾ä¸‹é¢‘ç¹æ›´æ–°è®¡æ•°å™¨
                if (lines && lines.length > 0 && !this.search.value.trim()) {
                    this.checkAndUpdateQuickSearchCounts();
                }

                if (!this.search.value.trim()) {
                    this.renderLogLines();
                } else {
                    setTimeout(() => {
                        if (targetLineIndex !== undefined) {
                            this.highlightTargetLine(targetLineIndex);
                        } else {
                            this.highlightLogContent(this.search.value.trim());
                        }
                    }, 10);
                }
            }

            handleSearchResult(payload) {
                setTimeout(() => {
                    this.matchPositions = payload;
                    this.applySearch(this.search.value.trim());
                    
                    // æœç´¢å®Œæˆåï¼Œé‡æ–°è®¡ç®—å¿«é€Ÿæœç´¢è®¡æ•°å™¨
                    // ç¡®ä¿è®¡æ•°å‡†ç¡®æ€§
                    if (this._isInitialized) {
                        this.checkAndUpdateQuickSearchCounts();
                    }
                }, 0);
            }

            handleSearchKeydown(e) {
                if (e.key === 'Enter') {
                    this.clearSearchHighlights();
                    const query = this.search.value.trim();
                    this.sendSearchRequest();

                    if (!query) return;

                    this.updateSearchHistory(query);
                } else if (e.key === 'ArrowUp') {
                    this.navigateHistory(-1);
                } else if (e.key === 'ArrowDown') {
                    this.navigateHistory(1);
                }
            }

            navigateHistory(direction) {
                if (this.searchHistory.length === 0) return;

                if (direction === -1) {
                    this.historyIndex = Math.max(0, this.historyIndex - 1);
                    this.search.value = this.searchHistory[this.historyIndex];
                } else {
                    this.historyIndex = Math.min(this.searchHistory.length, this.historyIndex + 1);
                    if (this.historyIndex === this.searchHistory.length) {
                        this.search.value = '';
                    } else {
                        this.search.value = this.searchHistory[this.historyIndex];
                    }
                }
            }

            updateSearchHistory(query) {
                if (!query || query.trim() === '') return;

                console.log('æ›´æ–°æœç´¢å†å²:', query);

                if (!this.searchHistory.includes(query)) {
                    this.searchHistory.push(query);
                    if (this.searchHistory.length > 100) {
                        this.searchHistory = this.searchHistory.slice(-100);
                    }
                } else {
                    this.searchHistory.splice(this.searchHistory.indexOf(query), 1);
                    this.searchHistory.push(query);
                }

                console.log('å½“å‰å†å²è®°å½•:', this.searchHistory);
                this.historyIndex = this.searchHistory.length;
                
                // ç«‹å³ä¿å­˜å†å²è®°å½•åˆ°åç«¯
                this.vscode.postMessage({ type: 'updateHistory', payload: this.searchHistory });
                
                // åŒæ—¶æ›´æ–°é¢æ¿çŠ¶æ€
                this.persistState();
            }

            applySearch(query) {
                if (!query) {
                    this.clearSearchHighlights();
                    this.renderLogLines();
                    this.hideMatchesDiv();
                    return;
                }

                this.showMatchesDiv();
                const currentMatchPositions = [...this.matchPositions];

                if (currentMatchPositions.length === 0) {
                    this.status.textContent = '0 / 0';
                    this.matchesDiv.innerHTML = '<div style="color:#888;">No matches found.</div>';
                    this.renderLogLines();
                    return;
                }

                const fragments = this.createSearchFragments(currentMatchPositions, query);
                this.updateCurrentMatchIndex(currentMatchPositions);
                this.updateStatus(currentMatchPositions);
                this.updateMatchList(fragments, currentMatchPositions);
                this.persistState();
            }

            createSearchFragments(matchPositions, query) {
                const fragments = [];

                for (let i = 0; i < matchPositions.length; i++) {
                    const { index, content, contentHash } = matchPositions[i];
                    let highlighted = '';

                    // å¤„ç†å†…å®¹ä¸­çš„è½¬ä¹‰å­—ç¬¦
                    const processedContent = this.processLogLine(content);

                    if (i === this.currentMatchIndex) {
                        highlighted = this.escapeHTML(processedContent).replace(new RegExp(this.escapeRegExp(query), 'gi'), match => {
                            return `<mark id="active" style="background: yellow; color: black;">${this.escapeHTML(match)}</mark>`;
                        });
                    } else {
                        highlighted = this.escapeHTML(processedContent).replace(new RegExp(this.escapeRegExp(query), 'gi'), match => {
                            return `<span style="background: rgba(255, 255, 0, 0.5); color: black;">${this.escapeHTML(match)}</span>`;
                        });
                    }

                    fragments.push({ index, context: highlighted, contentHash });
                }

                return fragments;
            }

            // è½¬ä¹‰æ­£åˆ™è¡¨è¾¾å¼ç‰¹æ®Šå­—ç¬¦
            escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            updateCurrentMatchIndex(matchPositions) {
                if (this.currentMatchIndex >= matchPositions.length) {
                    this.currentMatchIndex = matchPositions.length > 0 ? 0 : -1;
                }
            }

            updateStatus(matchPositions) {
                this.status.textContent = this.currentMatchIndex >= 0
                    ? `${this.currentMatchIndex + 1} / ${matchPositions.length}`
                    : `0 / ${matchPositions.length}`;
            }

            updateMatchList(fragments, matchPositionsData) {
                if (this.matchesDiv.children.length > 0 && this.matchesDiv.children.length === fragments.length) {
                    this.updateMatchListContent(fragments, matchPositionsData);
                } else {
                    this.renderMatchList(fragments, matchPositionsData);
                }
            }

            renderMatchList(list, matchPositionsData) {
                this.matchesDiv.innerHTML = '';

                for (let i = 0; i < list.length; i++) {
                    const item = list[i];
                    const div = this.createMatchItem(i, item, matchPositionsData);
                    this.matchesDiv.appendChild(div);
                }
            }

            createMatchItem(index, item, matchPositionsData) {
                const div = document.createElement('div');
                div.innerHTML = `<span style="cursor:pointer; color:#6cf;">[${index + 1}]</span> ${item.context}`;
                div.style.padding = '2px 4px';
                div.style.borderBottom = '1px solid #4CAF50';
                div.style.cursor = 'pointer';
                div.style.pointerEvents = 'auto';
                div.style.whiteSpace = 'nowrap';
                div.style.overflow = 'hidden';
                div.style.textOverflow = 'ellipsis';
                div.style.borderRadius = '2px';
                div.style.margin = '1px 0';
                div.style.transition = 'background-color 0.2s ease, border 0.2s ease, box-shadow 0.2s ease';
                div.style.lineHeight = '1.2';

                // è®¾ç½®æ•°æ®å±æ€§
                div.dataset.matchIndex = index;
                div.dataset.logIndex = matchPositionsData[index].index;
                div.dataset.contentHash = matchPositionsData[index].contentHash;

                this.updateMatchItemHighlight(div, index);

                return div;
            }

            updateMatchItemHighlight(div, index) {
                if (index === this.currentMatchIndex && this.currentMatchIndex >= 0) {
                    div.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                    div.style.border = '1px solid #4CAF50';
                    div.style.boxShadow = '0 0 4px rgba(76, 175, 80, 0.4)';
                } else {
                    div.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    div.style.border = '1px solid transparent';
                    div.style.boxShadow = 'none';
                }
            }

            handleMatchesDivClick(event) {
                // äº‹ä»¶å§”æ‰˜å¤„ç†åŒ¹é…é¡¹ç‚¹å‡»
                const target = event.target.closest('div[data-match-index]');
                if (!target) return;

                const matchIndex = parseInt(target.dataset.matchIndex);
                const logIndex = parseInt(target.dataset.logIndex);
                const contentHash = target.dataset.contentHash;

                this.currentMatchIndex = matchIndex;
                this.status.textContent = `${this.currentMatchIndex + 1} / ${this.matchPositions.length}`;
                this.updateMatchListHighlight();

                this.vscode.postMessage({
                    type: 'getLogByIndex',
                    index: logIndex,
                    contentHash: contentHash
                });
            }

            handleQuickSearchClick(event) {
                // ä½¿ç”¨äº‹ä»¶å§”æ‰˜ï¼Œæ‰¾åˆ°è¢«ç‚¹å‡»çš„å¿«é€Ÿæœç´¢æ ‡ç­¾
                const target = event.target.closest('.quick-search-label');
                if (!target) return;

                const searchText = target.dataset.search;
                if (searchText) {
                    console.log('å¿«é€Ÿæœç´¢æ ‡ç­¾è¢«ç‚¹å‡»:', searchText);
                    this.search.value = searchText;
                    this.search.focus();

                    // è‡ªåŠ¨è§¦å‘æœç´¢
                    this.sendSearchRequest();
                    this.updateSearchHistory(searchText);
                }
            }

            handleUpdateQuickSearchCounts(payload, colors) {
                // æ›´æ–°è®¡æ•°å™¨ - ä½¿ç”¨åç«¯æä¾›çš„æ•°æ®ï¼Œé¿å…æœ¬åœ°è®¡ç®—å†²çª
                Object.keys(payload).forEach(keyword => {
                    this.quickSearchCounts.set(keyword, payload[keyword]);
                });

                // å¦‚æœæ˜¯ç¬¬ä¸€æ¬¡æ”¶åˆ°æ•°æ®ï¼Œä»åç«¯è·å–å…³é”®è¯é…ç½®å¹¶åˆå§‹åŒ–æ ‡ç­¾
                if (this.quickSearchLabels.size === 0) {
                    // ä»è®¡æ•°å™¨æ•°æ®ä¸­æå–å…³é”®è¯åˆ—è¡¨
                    this.quickSearchKeywords = Object.keys(payload);

                    // å¦‚æœåç«¯æä¾›äº†é¢œè‰²é…ç½®ï¼Œä½¿ç”¨åç«¯çš„é…ç½®
                    if (colors && Array.isArray(colors) && colors.length > 0) {
                        this.quickSearchColors = [...colors];
                        console.log('ä½¿ç”¨åç«¯æä¾›çš„é¢œè‰²é…ç½®:', this.quickSearchColors);
                    }

                    this.initializeQuickSearchLabels();
                    // æ ‡è®°åˆå§‹åŒ–å®Œæˆ
                    this._isInitialized = true;
                } else {
                    // å¦‚æœæ ‡ç­¾å·²ç»å­˜åœ¨ï¼Œåªæ›´æ–°è®¡æ•°å™¨æ˜¾ç¤º
                    this.updateQuickSearchCounts();
                }
            }

            // æ›´æ–°å¿«é€Ÿæœç´¢æ ‡ç­¾é¢œè‰²é…ç½®
            updateQuickSearchColors(newColors) {
                if (Array.isArray(newColors) && newColors.length > 0) {
                    this.quickSearchColors = [...newColors];
                    console.log('å¿«é€Ÿæœç´¢æ ‡ç­¾é¢œè‰²é…ç½®å·²æ›´æ–°:', this.quickSearchColors);
                }
            }

            initializeQuickSearchLabels() {
                // æ¸…ç©ºå®¹å™¨
                this.quickSearchLabelsContainer.innerHTML = '';

                // ä¸ºæ¯ä¸ªå…³é”®è¯åˆ›å»ºæ ‡ç­¾
                Array.from(this.quickSearchKeywords).forEach((keyword, index) => {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'quick-search-label';
                    labelDiv.dataset.search = keyword;
                    labelDiv.title = `ç‚¹å‡»æœç´¢: ${keyword}`; // æ·»åŠ æç¤ºä¿¡æ¯

                    // ä½¿ç”¨å¯é…ç½®çš„é¢œè‰²æ•°ç»„
                    const color = this.quickSearchColors[index % this.quickSearchColors.length];

                    labelDiv.style.cssText = `
                        color: ${color}; 
                        font-size: 11px; 
                        cursor: pointer; 
                        padding: 2px 6px; 
                        border-radius: 3px; 
                        background: ${color}20; 
                        border: 1px solid ${color}50;
                        margin-right: 8px;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;

                    // æ·»åŠ æ‚¬åœæ•ˆæœ
                    labelDiv.addEventListener('mouseenter', () => {
                        labelDiv.style.background = `${color}40`;
                        labelDiv.style.transform = 'scale(1.05)';
                    });

                    labelDiv.addEventListener('mouseleave', () => {
                        labelDiv.style.background = `${color}20`;
                        labelDiv.style.transform = 'scale(1)';
                    });

                    // åˆ›å»ºè®¡æ•°å™¨span
                    const countSpan = document.createElement('span');
                    countSpan.id = `count_${keyword}`;
                    countSpan.style.cssText = `
                        background: ${color}; 
                        color: white; 
                        padding: 1px 4px; 
                        border-radius: 2px; 
                        font-size: 10px; 
                        margin-left: 4px;
                    `;
                    countSpan.textContent = '0';

                    // è®¾ç½®æ ‡ç­¾å†…å®¹
                    labelDiv.innerHTML = `${keyword} `;
                    labelDiv.appendChild(countSpan);

                    // å­˜å‚¨å¼•ç”¨
                    this.quickSearchLabels.set(keyword, labelDiv);

                    // æ·»åŠ åˆ°å®¹å™¨
                    this.quickSearchLabelsContainer.appendChild(labelDiv);
                });
            }

            handleMatchItemClick(index, matchPositionsData) {
                // ä¿ç•™æ­¤æ–¹æ³•ç”¨äºå‘åå…¼å®¹ï¼Œä½†ç°åœ¨ä½¿ç”¨äº‹ä»¶å§”æ‰˜
                this.currentMatchIndex = index;
                this.status.textContent = `${this.currentMatchIndex + 1} / ${matchPositionsData.length}`;
                this.updateMatchListHighlight();

                const matchPosition = matchPositionsData[index];
                if (matchPosition) {
                    this.vscode.postMessage({
                        type: 'getLogByIndex',
                        index: matchPosition.index,
                        contentHash: matchPosition.contentHash
                    });
                }
            }

            updateMatchListHighlight() {
                const matchItems = this.matchesDiv.querySelectorAll('div');
                matchItems.forEach((div, index) => {
                    this.updateMatchItemHighlight(div, index);
                });
            }

            updateMatchListContent(fragments, matchPositionsData) {
                const matchItems = this.matchesDiv.querySelectorAll('div');
                const maxItems = Math.min(fragments.length, matchItems.length);

                for (let i = 0; i < maxItems; i++) {
                    const div = matchItems[i];
                    const fragment = fragments[i];
                    div.innerHTML = `<span style="cursor:pointer; color:#6cf;">[${i + 1}]</span> ${fragment.context}`;
                    this.updateMatchItemHighlight(div, i);

                    // æ›´æ–°æ•°æ®å±æ€§ï¼Œç”¨äºäº‹ä»¶å§”æ‰˜
                    div.dataset.matchIndex = i;
                    div.dataset.logIndex = matchPositionsData[i].index;
                    div.dataset.contentHash = matchPositionsData[i].contentHash;
                }

                if (fragments.length !== matchItems.length) {
                    this.renderMatchList(fragments, matchPositionsData);
                }
            }

            highlightLogContent(query) {
                if (!query || this.matchPositions.length === 0) return;

                const regex = new RegExp(this.escapeRegExp(query), 'gi');
                this.log.innerHTML = '';

                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);
                    const processedLine = this.processLogLine(line);
                    const highlightedLine = this.escapeHTML(processedLine).replace(regex, match => {
                        return `<span style="background: rgba(255, 255, 0, 0.5); color: black;">${this.escapeHTML(match)}</span>`;
                    });
                    lineDiv.innerHTML = highlightedLine;
                    this.log.appendChild(lineDiv);
                });
            }

            highlightTargetLine(targetLineIndex) {
                if (targetLineIndex < 0 || targetLineIndex >= this.currentLogLines.length) return;

                const targetLine = this.currentLogLines[targetLineIndex];
                if (!targetLine) return;

                this.log.innerHTML = '';

                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);

                    if (index === targetLineIndex) {
                        lineDiv.id = 'here';
                        lineDiv.style.background = 'linear-gradient(90deg, rgba(255, 255, 0, 0.4), rgba(255, 255, 0, 0.2))';
                        lineDiv.style.borderLeft = '4px solid #ffeb3b';
                        lineDiv.style.padding = '2px 4px';
                        lineDiv.style.margin = '1px 0';
                        lineDiv.style.boxShadow = '0 0 8px rgba(255, 255, 0, 0.3)';
                    }

                    const processedLine = this.processLogLine(line);
                    lineDiv.textContent = processedLine;
                    this.log.appendChild(lineDiv);
                });

                this.scrollToTargetLine();
            }

            createLogLineDiv(index) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'log-line';
                lineDiv.dataset.lineIndex = index;
                lineDiv.style.whiteSpace = 'pre-wrap';
                lineDiv.style.wordBreak = 'break-all';
                
                // æ·»åŠ åŒå‡»äº‹ä»¶ç›‘å¬å™¨
                lineDiv.addEventListener('dblclick', (event) => {
                    this.handleLogLineDoubleClick(event, index);
                });
                
                return lineDiv;
            }

            scrollToTargetLine() {
                setTimeout(() => {
                    const targetDiv = this.log.querySelector('#here');
                    if (targetDiv) {
                        const targetOffsetTop = targetDiv.offsetTop;
                        this.log.scrollTop = targetOffsetTop - this.log.clientHeight / 2 + targetDiv.clientHeight / 2;
                    }
                }, 10);
            }

            renderLogLines() {
                const needScroll = this.isAtBottom();
                if (!needScroll) {
                    return;
                }
                this.log.innerHTML = '';
                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);
                    // å¤„ç† JSON ä¸­çš„ \n å­—ç¬¦ï¼Œè½¬æ¢ä¸ºå®é™…æ¢è¡Œ
                    const processedLine = this.processLogLine(line);
                    lineDiv.textContent = processedLine;
                    this.log.appendChild(lineDiv);
                });
                if (needScroll) {
                    this.log.scrollTop = this.log.scrollHeight;
                }

                // ç§»é™¤è¿™é‡Œçš„å¿«é€Ÿæœç´¢è®¡æ•°å™¨æ›´æ–°ï¼Œé¿å…é‡å¤è°ƒç”¨
                // è®¡æ•°å™¨æ›´æ–°å·²ç»åœ¨ handleLog ä¸­å¤„ç†
            }

            clearSearchHighlights() {
                this.matchPositions = [];
                this.currentMatchIndex = -1;
                this.status.textContent = '';
                this.matchesDiv.innerHTML = '';
                this.persistState();
            }

            showMatchesDiv() {
                this.matchesDiv.style.display = 'block';
            }

            hideMatchesDiv() {
                this.matchesDiv.style.display = 'none';
            }

            clearLog() {
                this.currentLogLines = [];
                this.log.innerHTML = '';

                // é‡ç½®æ‰€æœ‰å¿«é€Ÿæœç´¢è®¡æ•°å™¨
                Array.from(this.quickSearchKeywords).forEach(keyword => {
                    this.quickSearchCounts.set(keyword, 0);
                });
                this.updateQuickSearchCounts();

                this.vscode.postMessage({ type: 'clearLog' });
            }

            sendSearchRequest() {
                this.vscode.postMessage({
                    type: 'searchLog',
                    query: this.search.value.trim(),
                });
            }

            escapeHTML(str) {
                return str.replace(/[&<>"']/g, s => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
                }[s]));
            }

            restoreState() {
                const cached = this.vscode.getState();
                if (cached) {
                    if (cached.searchText) this.search.value = cached.searchText;
                    if (cached.matchIndex !== undefined) this.currentMatchIndex = cached.matchIndex;
                }
            }

            requestInitialState() {
                this.vscode.postMessage({ type: 'getStateRequest' });
            }

            requestHistory() {
                this.vscode.postMessage({ type: 'getHistoryRequest' });
            }

            persistState() {
                this.vscode.setState({
                    searchText: this.search.value.trim(),
                    matchIndex: this.currentMatchIndex,
                    scrollTop: this.log.scrollTop,
                });
                this.vscode.postMessage({
                    type: 'updatePanelState',
                    payload: {
                        searchText: this.search.value.trim(),
                        matchIndex: this.currentMatchIndex,
                        scrollTop: this.log.scrollTop,
                    }
                });
            }

            // å¤„ç†æ—¥å¿—è¡Œä¸­çš„è½¬ä¹‰å­—ç¬¦
            processLogLine(line) {
                if (!line) return line;

                // å¤„ç†å¸¸è§çš„è½¬ä¹‰å­—ç¬¦
                return line
                    .replace(/\\n/g, '\n')        // \n -> æ¢è¡Œ
                    .replace(/\\t/g, '\t')        // \t -> åˆ¶è¡¨ç¬¦
                    .replace(/\\r/g, '\r')        // \r -> å›è½¦
                    .replace(/\\"/g, '"')         // \" -> åŒå¼•å·
                    .replace(/\\'/g, "'")         // \' -> å•å¼•å·
                    .replace(/\\\\/g, '\\');      // \\ -> åæ–œæ 
            }

            // åˆ¤æ–­æ˜¯å¦åœ¨åº•éƒ¨ï¼ˆç²¾ç¡®åˆ¤æ–­ï¼‰
            isAtBottom() {
                const threshold = 1; // å…è®¸1åƒç´ çš„è¯¯å·®
                return Math.abs(this.log.scrollTop + this.log.clientHeight - this.log.scrollHeight) <= threshold;
            }

            // æ›´æ–°å¿«é€Ÿæœç´¢è®¡æ•°å™¨
            updateQuickSearchCounts() {
                // æ‰¹é‡æ›´æ–°ï¼Œé¿å…é¢‘ç¹DOMæ“ä½œ
                const updates = [];
                
                this.quickSearchCounts.forEach((count, keyword) => {
                    const countSpan = document.getElementById(`count_${keyword}`);
                    if (countSpan) {
                        updates.push({ element: countSpan, count: count.toString() });
                    }
                });
                
                // ä½¿ç”¨ requestAnimationFrame æ‰¹é‡æ›´æ–°DOM
                if (updates.length > 0) {
                    requestAnimationFrame(() => {
                        updates.forEach(({ element, count }) => {
                            if (element.textContent !== count) {
                                element.textContent = count;
                            }
                        });
                    });
                }
            }

            // æ£€æŸ¥å¹¶æ›´æ–°å¿«é€Ÿæœç´¢è®¡æ•°
            checkAndUpdateQuickSearchCounts() {
                // åœ¨åˆå§‹åŒ–å®Œæˆå‰ï¼Œä¸æ‰§è¡Œæœ¬åœ°è®¡ç®—
                if (!this._isInitialized) {
                    return;
                }

                // é˜²æŠ–ï¼šé¿å…çŸ­æ—¶é—´å†…é‡å¤è°ƒç”¨
                if (this._quickSearchUpdateTimer) {
                    clearTimeout(this._quickSearchUpdateTimer);
                }

                this._quickSearchUpdateTimer = setTimeout(() => {
                    this._performQuickSearchUpdate();
                }, 200); // å¢åŠ é˜²æŠ–æ—¶é—´åˆ°200ms
            }

            // å¤„ç†æ—¥å¿—è¡ŒåŒå‡»äº‹ä»¶
            handleLogLineDoubleClick(event, lineIndex) {
                const line = this.currentLogLines[lineIndex];
                if (!line) {
                    console.error('åŒå‡»äº‹ä»¶: æœªæ‰¾åˆ°è¡Œå†…å®¹, lineIndex:', lineIndex);
                    return;
                }
                
                // è·å–ç‚¹å‡»ä½ç½®ç›¸å¯¹äºå½“å‰è¡Œçš„åç§»
                const lineDiv = event.currentTarget;
                const rect = lineDiv.getBoundingClientRect();
                const clickY = event.clientY - rect.top;
                
                // è®¡ç®—ç‚¹å‡»çš„æ˜¯è¯¥æ—¥å¿—è¡Œä¸­çš„ç¬¬å‡ è¡Œ
                const lineHeight = this.getLineHeight();
                const clickedLineIndex = Math.max(0, Math.floor(clickY / lineHeight));
                
                // è°ƒè¯•ä¿¡æ¯
                console.log('=== åŒå‡»äº‹ä»¶ä¿¡æ¯ ===');
                console.log('åŒå‡»äº‹ä»¶ä¿¡æ¯:', {
                    lineIndex,
                    clickY,
                    lineHeight,
                    clickedLineIndex,
                    totalLines: lineDiv.textContent.split('\n').length,
                    originalLine: line.substring(0, 200) + '...',
                    displayText: lineDiv.textContent.substring(0, 200) + '...'
                });
                
                // è§£ææ—¥å¿—ä¸­çš„æ–‡ä»¶åå’Œè¡Œå·ï¼Œè€ƒè™‘å¤šè¡Œæƒ…å†µ
                const fileInfo = this.parseLogLineForFileInfo(line, clickedLineIndex);
                if (fileInfo) {
                    console.log('=== è§£ææˆåŠŸ ===');
                    console.log('è§£æåˆ°çš„æ–‡ä»¶ä¿¡æ¯:', fileInfo);
                    // å‘é€è·³è½¬è¯·æ±‚åˆ°åç«¯
                    this.vscode.postMessage({
                        type: 'jumpToFile',
                        payload: fileInfo
                    });
                } else {
                    console.log('=== è§£æå¤±è´¥ ===');
                    console.log('æœªæ‰¾åˆ°æ–‡ä»¶ä¿¡æ¯');
                    
                    // å°è¯•åœ¨æ˜¾ç¤ºæ–‡æœ¬ä¸­æŸ¥æ‰¾æ–‡ä»¶ä¿¡æ¯
                    console.log('å°è¯•åœ¨æ˜¾ç¤ºæ–‡æœ¬ä¸­æŸ¥æ‰¾...');
                    const displayFileInfo = this.parseLogLineForFileInfo(lineDiv.textContent, clickedLineIndex);
                    if (displayFileInfo) {
                        console.log('åœ¨æ˜¾ç¤ºæ–‡æœ¬ä¸­æ‰¾åˆ°æ–‡ä»¶ä¿¡æ¯:', displayFileInfo);
                        this.vscode.postMessage({
                            type: 'jumpToFile',
                            payload: displayFileInfo
                        });
                    } else {
                        console.log('æ˜¾ç¤ºæ–‡æœ¬ä¸­ä¹Ÿæ²¡æœ‰æ‰¾åˆ°æ–‡ä»¶ä¿¡æ¯');
                    }
                }
                console.log('==================');
            }
            
            // è·å–è¡Œé«˜
            getLineHeight() {
                // åˆ›å»ºä¸€ä¸ªä¸´æ—¶å…ƒç´ æ¥æµ‹é‡è¡Œé«˜
                const tempDiv = document.createElement('div');
                tempDiv.style.fontSize = window.getComputedStyle(this.log).fontSize;
                tempDiv.style.fontFamily = window.getComputedStyle(this.log).fontFamily;
                tempDiv.style.lineHeight = 'normal';
                tempDiv.textContent = 'A';
                document.body.appendChild(tempDiv);
                const lineHeight = tempDiv.offsetHeight;
                document.body.removeChild(tempDiv);
                return lineHeight;
            }
            
            // è§£ææ—¥å¿—è¡Œä¸­çš„æ–‡ä»¶ä¿¡æ¯ï¼Œæ”¯æŒå¤šè¡Œæƒ…å†µ
            parseLogLineForFileInfo(line, clickedLineIndex = 0) {
                // å¤„ç†è½¬ä¹‰å­—ç¬¦ï¼Œä½†ä¿ç•™åŸå§‹å­—ç¬¦ä¸²ç”¨äºè§£æ
                const processedLine = this.processLogLine(line);
                
                console.log('=== å¼€å§‹è§£ææ–‡ä»¶ä¿¡æ¯ ===');
                console.log('åŸå§‹è¡Œ:', line);
                console.log('ç‚¹å‡»è¡Œç´¢å¼•:', clickedLineIndex);
                console.log('å¤„ç†åçš„è¡Œ:', processedLine);
                
                // æ¨¡å¼2: File "path/to/file.py", line 1277 (æ”¯æŒå¤šè¡Œï¼ŒåŒ…å«å¯é€‰çš„ in function_name) - ä¼˜å…ˆå¤„ç†
                const pattern2 = /File\s+"([^"]+\.py)",\s*line\s+(\d+)(?:\s+in\s+(\w+))?/;
                
                // åœ¨åŸå§‹è¡Œä¸­æŸ¥æ‰¾æ‰€æœ‰åŒ¹é…é¡¹
                const matches = [];
                let match;
                const regex = new RegExp(pattern2, 'g');
                
                while ((match = regex.exec(line)) !== null) {
                    const filePath = match[1];
                    const lineNumber = parseInt(match[2]);
                    const functionName = match[3] || null;
                    
                    if (!isNaN(lineNumber)) {
                        // è®¡ç®—è¿™ä¸ªåŒ¹é…é¡¹åœ¨è½¬ä¹‰åçš„æ–‡æœ¬ä¸­å¯¹åº”çš„è¡Œæ•°
                        const beforeMatch = line.substring(0, match.index);
                        const processedBefore = this.processLogLine(beforeMatch);
                        const lineCount = (processedBefore.match(/\n/g) || []).length;
                        
                        matches.push({
                            filePath,
                            lineNumber,
                            functionName,
                            lineCount,
                            matchIndex: match.index,
                            originalIndex: match.index
                        });
                        
                        console.log(`æ‰¾åˆ°æ¨¡å¼2åŒ¹é…:`, {
                            filePath,
                            lineNumber,
                            functionName,
                            lineCount,
                            matchIndex: match.index
                        });
                    }
                }
                
                // è°ƒè¯•ä¿¡æ¯
                console.log('æ–‡ä»¶ä¿¡æ¯åŒ¹é…ç»“æœ:', {
                    clickedLineIndex,
                    totalProcessedLines: processedLine.split('\n').length,
                    matches: matches.map(m => ({
                        filePath: m.filePath,
                        lineNumber: m.lineNumber,
                        functionName: m.functionName,
                        lineCount: m.lineCount
                    }))
                });
                
                // æ ¹æ®ç‚¹å‡»çš„è¡Œç´¢å¼•æ‰¾åˆ°å¯¹åº”çš„æ–‡ä»¶ä¿¡æ¯
                if (matches.length > 0) {
                    // æ‰¾åˆ°ç‚¹å‡»è¡Œå¯¹åº”çš„æ–‡ä»¶ä¿¡æ¯
                    for (let i = 0; i < matches.length; i++) {
                        const match = matches[i];
                        const nextMatch = matches[i + 1];
                        
                        // è®¡ç®—è¿™ä¸ªåŒ¹é…é¡¹å¯¹åº”çš„è¡ŒèŒƒå›´
                        const startLine = match.lineCount;
                        const endLine = nextMatch ? nextMatch.lineCount : startLine + 1;
                        
                        console.log(`æ£€æŸ¥åŒ¹é…é¡¹ ${i}:`, {
                            filePath: match.filePath,
                            lineNumber: match.lineNumber,
                            functionName: match.functionName,
                            startLine,
                            endLine,
                            clickedLineIndex,
                            isInRange: clickedLineIndex >= startLine && clickedLineIndex < endLine
                        });
                        
                        if (clickedLineIndex >= startLine && clickedLineIndex < endLine) {
                            const fileName = match.filePath.split(/[\\\/]/).pop();
                            console.log('æ‰¾åˆ°åŒ¹é…çš„æ–‡ä»¶ä¿¡æ¯:', {
                                fileName,
                                lineNumber: match.lineNumber,
                                functionName: match.functionName,
                                fullPath: match.filePath,
                                clickedLineIndex,
                                startLine,
                                endLine
                            });
                            return { 
                                fileName, 
                                lineNumber: match.lineNumber, 
                                fullPath: match.filePath,
                                functionName: match.functionName
                            };
                        }
                    }
                    
                    // å¦‚æœç‚¹å‡»çš„è¡Œè¶…å‡ºèŒƒå›´ï¼Œè¿”å›æœ€åä¸€ä¸ªåŒ¹é…é¡¹
                    const lastMatch = matches[matches.length - 1];
                    const fileName = lastMatch.filePath.split(/[\\\/]/).pop();
                    console.log('ä½¿ç”¨æœ€åä¸€ä¸ªåŒ¹é…é¡¹:', {
                        fileName,
                        lineNumber: lastMatch.lineNumber,
                        functionName: lastMatch.functionName,
                        fullPath: lastMatch.filePath
                    });
                    return { 
                        fileName, 
                        lineNumber: lastMatch.lineNumber, 
                        fullPath: lastMatch.filePath,
                        functionName: lastMatch.functionName
                    };
                }
                
                // å¦‚æœæ²¡æœ‰æ‰¾åˆ° File "path.py", line 123 æ ¼å¼çš„åŒ¹é…ï¼Œä¸”ç‚¹å‡»çš„æ˜¯ç¬¬ä¸€è¡Œï¼Œæ‰ä½¿ç”¨æ¨¡å¼1
                if (clickedLineIndex === 0) {
                    // æ¨¡å¼1: ProcessBase.py65 - æ–‡ä»¶å.pyè¡Œå·
                    const pattern1 = /(\w+\.py\d+)/;
                    const match1 = line.match(pattern1);
                    if (match1) {
                        const fullMatch = match1[1];
                        const dotIndex = fullMatch.lastIndexOf('.');
                        if (dotIndex > 0) {
                            const fileName = fullMatch.substring(0, dotIndex + 3); // åŒ…å«.py
                            const lineNumber = parseInt(fullMatch.substring(dotIndex + 3));
                            if (!isNaN(lineNumber)) {
                                console.log('ä½¿ç”¨æ¨¡å¼1åŒ¹é…:', { fileName, lineNumber });
                                return { fileName, lineNumber };
                            }
                        }
                    }
                }
                
                console.log('æœªæ‰¾åˆ°ä»»ä½•æ–‡ä»¶ä¿¡æ¯');
                console.log('=== è§£æç»“æŸ ===');
                return null;
            }

            // å®é™…æ‰§è¡Œå¿«é€Ÿæœç´¢æ›´æ–°çš„æ–¹æ³•
            _performQuickSearchUpdate() {
                // ä¸å†é‡ç½®è®¡æ•°å™¨ï¼Œè€Œæ˜¯å¢é‡æ›´æ–°
                // è¿™æ ·å¯ä»¥é¿å…è®¡æ•°å™¨é—ªåŠ¨
                
                // æ£€æŸ¥å½“å‰æ—¥å¿—ç¼“å†²åŒºä¸­çš„åŒ¹é…
                // æ³¨æ„ï¼šè¿™é‡Œåº”è¯¥åªè®¡ç®—æ–°å¢çš„åŒ¹é…ï¼Œè€Œä¸æ˜¯é‡æ–°è®¡ç®—å…¨éƒ¨
                // ç”±äºåç«¯å·²ç»å¤„ç†äº†è®¡æ•°ï¼Œå‰ç«¯ä¸»è¦è´Ÿè´£æ˜¾ç¤ºæ›´æ–°
                
                // å¦‚æœåç«¯æ²¡æœ‰æä¾›è®¡æ•°ï¼Œæ‰è¿›è¡Œæœ¬åœ°è®¡ç®—
                if (this.quickSearchCounts.size === 0) {
                    this.currentLogLines.forEach(line => {
                        Array.from(this.quickSearchKeywords).forEach(keyword => {
                            if (line.toLowerCase().includes(keyword.toLowerCase())) {
                                const currentCount = this.quickSearchCounts.get(keyword) || 0;
                                this.quickSearchCounts.set(keyword, currentCount + 1);
                            }
                        });
                    });
                }

                this.updateQuickSearchCounts();
            }
        }

        // åˆå§‹åŒ–åº”ç”¨
        function initLogViewer() {
            try {
                new LogViewer();
            } catch (error) {
                console.error('Failed to initialize LogViewer:', error);
                // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
                document.body.innerHTML = `
                    <div style="padding: 20px; color: white; background: #1e1e1e; height: 100%;">
                        <h3>Log Viewer åˆå§‹åŒ–å¤±è´¥</h3>
                        <p>é”™è¯¯ä¿¡æ¯: ${error.message}</p>
                        <button onclick="location.reload()" style="padding: 8px 16px; margin-top: 10px;">
                            é‡æ–°åŠ è½½
                        </button>
                    </div>
                `;
            }
        }

        // ç­‰å¾… DOM å®Œå…¨åŠ è½½åå†åˆå§‹åŒ–
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initLogViewer);
        } else {
            initLogViewer();
        }
    </script>
</body>

</html>