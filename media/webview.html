<!DOCTYPE html>
<html style="height: 100%;">

<head>
    <meta charset="utf-8" />
    <title>Log Viewer</title>
</head>

<body style="height: 100%; margin: 0; display: flex; flex-direction: column; font-family: sans-serif;">

    <div style="padding: 3px; background: #2d2d2d; display: flex; align-items: center; gap: 12px;">
        <!-- 左半部分：搜索区域 -->
        <div
            style="flex: 1; display: flex; align-items: center; background: #3a3a3a; border: 1px solid #555; border-radius: 6px; padding: 4px;">
            <div style="color: #4CAF50; font-weight: bold; font-size: 12px; margin-right: 8px; white-space: nowrap;">🔍
                搜索</div>
            <input id="search" type="text" placeholder="Search logs..."
                style="flex: 1; padding: 4px 6px; border: 1px solid #666; border-radius: 3px; background: #2a2a2a; color: white;" />

            <!-- 快速搜索标签 -->
            <div id="quickSearchLabels" style="display: flex; align-items: center; gap: 8px; margin-left: 8px;">
                <!-- 动态生成的快速搜索标签将在这里 -->
            </div>

            <button id="clearLogBtn"
                style="margin-left: 8px; padding: 3px 6px; background: #f44336; color: white; border: none; border-radius: 3px; cursor: pointer;">清除日志</button>
            <div id="status" style="color: white; margin-left: 6px; white-space: nowrap;"></div>
        </div>

        <!-- 右半部分：GM指令区域 -->
        <div
            style="flex: 1; display: flex; align-items: center; background: #4a3a4a; border: 1px solid #665566; border-radius: 6px; padding: 4px;">
            <div style="color: #FF9800; font-weight: bold; font-size: 12px; margin-right: 8px; white-space: nowrap;">⚡
                GM指令</div>
            <input id="gmCommand" type="text" placeholder="请输入GM指令..."
                style="flex: 1; padding: 4px 6px; border: 1px solid #776677; border-radius: 3px; background: #3a2a3a; color: white;" />
        </div>
    </div>

    <pre id="log"
        style="flex: 1; background: #1e1e1e; color: white; margin: 0; padding: 10px; overflow: auto; white-space: pre-wrap;"></pre>

    <div id="matches"
        style="max-height: 100px; overflow-y: auto; background: #3a3a3a; color: #ccc; font-size: 12px; border: 1px solid #4CAF50; border-radius: 4px; padding: 4px; margin: 3px; white-space: nowrap; box-shadow: 0 1px 2px rgba(0,0,0,0.3);">
    </div>

    <script>
        // Webview 主逻辑
        class LogViewer {
            constructor() {
                try {
                    this.vscode = acquireVsCodeApi();
                } catch (error) {
                    console.error('Failed to acquire VS Code API:', error);
                    // 创建一个模拟的 vscode API 用于开发测试
                    this.vscode = {
                        postMessage: (msg) => console.log('Mock postMessage:', msg),
                        getState: () => null,
                        setState: (state) => console.log('Mock setState:', state)
                    };
                }

                this.currentLogLines = [];
                this.matchPositions = [];
                this.currentMatchIndex = -1;
                this.searchHistory = [];
                this.historyIndex = -1;
                this.searchTimeout = null;

                // 快速搜索关键词 - 默认值，会被后端配置覆盖
                this.quickSearchKeywords = ['all_succ', 'traceback'];

                // 快速搜索标签颜色配置 - 可配置的颜色数组
                this.quickSearchColors = ['#4CAF50', '#FF9800', '#E91E63', '#2196F3', '#9C27B0', '#FF5722'];

                // 快速搜索计数器 - 动态生成
                this.quickSearchCounts = new Map();
                this.quickSearchLabels = new Map(); // 存储标签元素的引用
                this._isInitialized = false; // 初始化状态标志

                this.initElements();
                this.initEventListeners();
                this.hideMatchesDiv(); // 初始化时隐藏匹配栏
                this.restoreState();
                
                // 延迟请求初始状态和历史记录，确保前端完全初始化
                setTimeout(() => {
                    this.requestInitialState();
                    this.requestHistory();
                }, 100);

                // 初始化快速搜索计数器 - 延迟执行，避免初始化时的重复调用
                setTimeout(() => {
                    this.checkAndUpdateQuickSearchCounts();
                }, 100);
            }

            initElements() {
                this.log = document.getElementById('log');
                this.search = document.getElementById('search');
                this.status = document.getElementById('status');
                this.matchesDiv = document.getElementById('matches');
                this.clearLogBtn = document.getElementById('clearLogBtn');

                // 快速搜索标签容器
                this.quickSearchLabelsContainer = document.getElementById('quickSearchLabels');
            }

            initEventListeners() {
                // 消息监听
                window.addEventListener('message', this.handleMessage.bind(this));

                // 清除日志按钮
                this.clearLogBtn.addEventListener('click', this.clearLog.bind(this));

                // 搜索相关事件
                this.search.addEventListener('keydown', this.handleSearchKeydown.bind(this));

                // 匹配项点击事件委托
                this.matchesDiv.addEventListener('click', this.handleMatchesDivClick.bind(this));

                // 快速搜索标签点击事件委托
                this.quickSearchLabelsContainer.addEventListener('click', this.handleQuickSearchClick.bind(this));

                // 快速搜索标签点击事件将通过事件委托处理

                // 定期保存状态
                setInterval(() => this.persistState(), 1000);
            }

            handleMessage(event) {
                const { type, lines, history, payload, targetLineIndex, colors } = event.data;

                switch (type) {
                    case 'history':
                        this.handleHistory(history);
                        break;
                    case 'restorePanelState':
                        this.handleRestorePanelState(payload);
                        break;
                    case 'log':
                        this.handleLog(lines, targetLineIndex);
                        break;
                    case 'searchResult':
                        this.handleSearchResult(payload);
                        break;
                    case 'updateQuickSearchCounts':
                        this.handleUpdateQuickSearchCounts(payload, colors);
                        break;
                    case 'updateQuickSearchColors':
                        this.updateQuickSearchColors(payload);
                        break;
                }
            }

            handleHistory(history) {
                console.log('收到历史记录:', history);
                if (Array.isArray(history)) {
                    this.searchHistory = [...history];
                    this.historyIndex = this.searchHistory.length;
                    console.log('历史记录已加载，共', this.searchHistory.length, '条');
                    
                    // 如果有历史记录，恢复最后一个搜索文本到搜索框
                    if (this.searchHistory.length > 0) {
                        const lastSearchText = this.searchHistory[this.searchHistory.length - 1];
                        if (lastSearchText && lastSearchText.trim()) {
                            this.search.value = lastSearchText;
                            console.log('恢复搜索文本:', lastSearchText);
                        }
                    }
                } else {
                    console.warn('历史记录格式错误:', history);
                    this.searchHistory = [];
                    this.historyIndex = 0;
                }
            }

            handleRestorePanelState(payload) {
                console.log('恢复面板状态:', payload);
                if (payload.searchText) {
                    this.search.value = payload.searchText;
                    this.currentMatchIndex = payload.matchIndex || -1;
                    
                    // 确保搜索文本也被添加到历史记录中
                    if (payload.searchText.trim() && !this.searchHistory.includes(payload.searchText)) {
                        this.searchHistory.push(payload.searchText);
                        this.historyIndex = this.searchHistory.length;
                        console.log('添加搜索文本到历史记录:', payload.searchText);
                    }
                    
                    // 延迟执行搜索，确保状态已完全恢复
                    setTimeout(() => {
                        this.applySearch(this.search.value);
                    }, 100);
                } else {
                    this.hideMatchesDiv();
                }
                if (payload.scrollTop !== undefined) {
                    setTimeout(() => { this.log.scrollTop = payload.scrollTop; }, 100);
                }
            }

            handleLog(lines, targetLineIndex) {
                this.currentLogLines = lines || [];

                // 更新快速搜索计数器 - 只在有实际日志数据且不是搜索视图时更新
                // 避免在搜索视图下频繁更新计数器
                if (lines && lines.length > 0 && !this.search.value.trim()) {
                    this.checkAndUpdateQuickSearchCounts();
                }

                if (!this.search.value.trim()) {
                    this.renderLogLines();
                } else {
                    setTimeout(() => {
                        if (targetLineIndex !== undefined) {
                            this.highlightTargetLine(targetLineIndex);
                        } else {
                            this.highlightLogContent(this.search.value.trim());
                        }
                    }, 10);
                }
            }

            handleSearchResult(payload) {
                setTimeout(() => {
                    this.matchPositions = payload;
                    this.applySearch(this.search.value.trim());
                    
                    // 搜索完成后，重新计算快速搜索计数器
                    // 确保计数准确性
                    if (this._isInitialized) {
                        this.checkAndUpdateQuickSearchCounts();
                    }
                }, 0);
            }

            handleSearchKeydown(e) {
                if (e.key === 'Enter') {
                    this.clearSearchHighlights();
                    const query = this.search.value.trim();
                    this.sendSearchRequest();

                    if (!query) return;

                    this.updateSearchHistory(query);
                } else if (e.key === 'ArrowUp') {
                    this.navigateHistory(-1);
                } else if (e.key === 'ArrowDown') {
                    this.navigateHistory(1);
                }
            }

            navigateHistory(direction) {
                if (this.searchHistory.length === 0) return;

                if (direction === -1) {
                    this.historyIndex = Math.max(0, this.historyIndex - 1);
                    this.search.value = this.searchHistory[this.historyIndex];
                } else {
                    this.historyIndex = Math.min(this.searchHistory.length, this.historyIndex + 1);
                    if (this.historyIndex === this.searchHistory.length) {
                        this.search.value = '';
                    } else {
                        this.search.value = this.searchHistory[this.historyIndex];
                    }
                }
            }

            updateSearchHistory(query) {
                if (!query || query.trim() === '') return;

                console.log('更新搜索历史:', query);

                if (!this.searchHistory.includes(query)) {
                    this.searchHistory.push(query);
                    if (this.searchHistory.length > 100) {
                        this.searchHistory = this.searchHistory.slice(-100);
                    }
                } else {
                    this.searchHistory.splice(this.searchHistory.indexOf(query), 1);
                    this.searchHistory.push(query);
                }

                console.log('当前历史记录:', this.searchHistory);
                this.historyIndex = this.searchHistory.length;
                
                // 立即保存历史记录到后端
                this.vscode.postMessage({ type: 'updateHistory', payload: this.searchHistory });
                
                // 同时更新面板状态
                this.persistState();
            }

            applySearch(query) {
                if (!query) {
                    this.clearSearchHighlights();
                    this.renderLogLines();
                    this.hideMatchesDiv();
                    return;
                }

                this.showMatchesDiv();
                const currentMatchPositions = [...this.matchPositions];

                if (currentMatchPositions.length === 0) {
                    this.status.textContent = '0 / 0';
                    this.matchesDiv.innerHTML = '<div style="color:#888;">No matches found.</div>';
                    this.renderLogLines();
                    return;
                }

                const fragments = this.createSearchFragments(currentMatchPositions, query);
                this.updateCurrentMatchIndex(currentMatchPositions);
                this.updateStatus(currentMatchPositions);
                this.updateMatchList(fragments, currentMatchPositions);
                this.persistState();
            }

            createSearchFragments(matchPositions, query) {
                const fragments = [];

                for (let i = 0; i < matchPositions.length; i++) {
                    const { index, content, contentHash } = matchPositions[i];
                    let highlighted = '';

                    // 处理内容中的转义字符
                    const processedContent = this.processLogLine(content);

                    if (i === this.currentMatchIndex) {
                        highlighted = this.escapeHTML(processedContent).replace(new RegExp(this.escapeRegExp(query), 'gi'), match => {
                            return `<mark id="active" style="background: yellow; color: black;">${this.escapeHTML(match)}</mark>`;
                        });
                    } else {
                        highlighted = this.escapeHTML(processedContent).replace(new RegExp(this.escapeRegExp(query), 'gi'), match => {
                            return `<span style="background: rgba(255, 255, 0, 0.5); color: black;">${this.escapeHTML(match)}</span>`;
                        });
                    }

                    fragments.push({ index, context: highlighted, contentHash });
                }

                return fragments;
            }

            // 转义正则表达式特殊字符
            escapeRegExp(string) {
                return string.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            updateCurrentMatchIndex(matchPositions) {
                if (this.currentMatchIndex >= matchPositions.length) {
                    this.currentMatchIndex = matchPositions.length > 0 ? 0 : -1;
                }
            }

            updateStatus(matchPositions) {
                this.status.textContent = this.currentMatchIndex >= 0
                    ? `${this.currentMatchIndex + 1} / ${matchPositions.length}`
                    : `0 / ${matchPositions.length}`;
            }

            updateMatchList(fragments, matchPositionsData) {
                if (this.matchesDiv.children.length > 0 && this.matchesDiv.children.length === fragments.length) {
                    this.updateMatchListContent(fragments, matchPositionsData);
                } else {
                    this.renderMatchList(fragments, matchPositionsData);
                }
            }

            renderMatchList(list, matchPositionsData) {
                this.matchesDiv.innerHTML = '';

                for (let i = 0; i < list.length; i++) {
                    const item = list[i];
                    const div = this.createMatchItem(i, item, matchPositionsData);
                    this.matchesDiv.appendChild(div);
                }
            }

            createMatchItem(index, item, matchPositionsData) {
                const div = document.createElement('div');
                div.innerHTML = `<span style="cursor:pointer; color:#6cf;">[${index + 1}]</span> ${item.context}`;
                div.style.padding = '2px 4px';
                div.style.borderBottom = '1px solid #4CAF50';
                div.style.cursor = 'pointer';
                div.style.pointerEvents = 'auto';
                div.style.whiteSpace = 'nowrap';
                div.style.overflow = 'hidden';
                div.style.textOverflow = 'ellipsis';
                div.style.borderRadius = '2px';
                div.style.margin = '1px 0';
                div.style.transition = 'background-color 0.2s ease, border 0.2s ease, box-shadow 0.2s ease';
                div.style.lineHeight = '1.2';

                // 设置数据属性
                div.dataset.matchIndex = index;
                div.dataset.logIndex = matchPositionsData[index].index;
                div.dataset.contentHash = matchPositionsData[index].contentHash;

                this.updateMatchItemHighlight(div, index);

                return div;
            }

            updateMatchItemHighlight(div, index) {
                if (index === this.currentMatchIndex && this.currentMatchIndex >= 0) {
                    div.style.backgroundColor = 'rgba(76, 175, 80, 0.3)';
                    div.style.border = '1px solid #4CAF50';
                    div.style.boxShadow = '0 0 4px rgba(76, 175, 80, 0.4)';
                } else {
                    div.style.backgroundColor = 'rgba(76, 175, 80, 0.1)';
                    div.style.border = '1px solid transparent';
                    div.style.boxShadow = 'none';
                }
            }

            handleMatchesDivClick(event) {
                // 事件委托处理匹配项点击
                const target = event.target.closest('div[data-match-index]');
                if (!target) return;

                const matchIndex = parseInt(target.dataset.matchIndex);
                const logIndex = parseInt(target.dataset.logIndex);
                const contentHash = target.dataset.contentHash;

                this.currentMatchIndex = matchIndex;
                this.status.textContent = `${this.currentMatchIndex + 1} / ${this.matchPositions.length}`;
                this.updateMatchListHighlight();

                this.vscode.postMessage({
                    type: 'getLogByIndex',
                    index: logIndex,
                    contentHash: contentHash
                });
            }

            handleQuickSearchClick(event) {
                // 使用事件委托，找到被点击的快速搜索标签
                const target = event.target.closest('.quick-search-label');
                if (!target) return;

                const searchText = target.dataset.search;
                if (searchText) {
                    console.log('快速搜索标签被点击:', searchText);
                    this.search.value = searchText;
                    this.search.focus();

                    // 自动触发搜索
                    this.sendSearchRequest();
                    this.updateSearchHistory(searchText);
                }
            }

            handleUpdateQuickSearchCounts(payload, colors) {
                // 更新计数器 - 使用后端提供的数据，避免本地计算冲突
                Object.keys(payload).forEach(keyword => {
                    this.quickSearchCounts.set(keyword, payload[keyword]);
                });

                // 如果是第一次收到数据，从后端获取关键词配置并初始化标签
                if (this.quickSearchLabels.size === 0) {
                    // 从计数器数据中提取关键词列表
                    this.quickSearchKeywords = Object.keys(payload);

                    // 如果后端提供了颜色配置，使用后端的配置
                    if (colors && Array.isArray(colors) && colors.length > 0) {
                        this.quickSearchColors = [...colors];
                        console.log('使用后端提供的颜色配置:', this.quickSearchColors);
                    }

                    this.initializeQuickSearchLabels();
                    // 标记初始化完成
                    this._isInitialized = true;
                } else {
                    // 如果标签已经存在，只更新计数器显示
                    this.updateQuickSearchCounts();
                }
            }

            // 更新快速搜索标签颜色配置
            updateQuickSearchColors(newColors) {
                if (Array.isArray(newColors) && newColors.length > 0) {
                    this.quickSearchColors = [...newColors];
                    console.log('快速搜索标签颜色配置已更新:', this.quickSearchColors);
                }
            }

            initializeQuickSearchLabels() {
                // 清空容器
                this.quickSearchLabelsContainer.innerHTML = '';

                // 为每个关键词创建标签
                Array.from(this.quickSearchKeywords).forEach((keyword, index) => {
                    const labelDiv = document.createElement('div');
                    labelDiv.className = 'quick-search-label';
                    labelDiv.dataset.search = keyword;
                    labelDiv.title = `点击搜索: ${keyword}`; // 添加提示信息

                    // 使用可配置的颜色数组
                    const color = this.quickSearchColors[index % this.quickSearchColors.length];

                    labelDiv.style.cssText = `
                        color: ${color}; 
                        font-size: 11px; 
                        cursor: pointer; 
                        padding: 2px 6px; 
                        border-radius: 3px; 
                        background: ${color}20; 
                        border: 1px solid ${color}50;
                        margin-right: 8px;
                        transition: all 0.2s ease;
                        user-select: none;
                    `;

                    // 添加悬停效果
                    labelDiv.addEventListener('mouseenter', () => {
                        labelDiv.style.background = `${color}40`;
                        labelDiv.style.transform = 'scale(1.05)';
                    });

                    labelDiv.addEventListener('mouseleave', () => {
                        labelDiv.style.background = `${color}20`;
                        labelDiv.style.transform = 'scale(1)';
                    });

                    // 创建计数器span
                    const countSpan = document.createElement('span');
                    countSpan.id = `count_${keyword}`;
                    countSpan.style.cssText = `
                        background: ${color}; 
                        color: white; 
                        padding: 1px 4px; 
                        border-radius: 2px; 
                        font-size: 10px; 
                        margin-left: 4px;
                    `;
                    countSpan.textContent = '0';

                    // 设置标签内容
                    labelDiv.innerHTML = `${keyword} `;
                    labelDiv.appendChild(countSpan);

                    // 存储引用
                    this.quickSearchLabels.set(keyword, labelDiv);

                    // 添加到容器
                    this.quickSearchLabelsContainer.appendChild(labelDiv);
                });
            }

            handleMatchItemClick(index, matchPositionsData) {
                // 保留此方法用于向后兼容，但现在使用事件委托
                this.currentMatchIndex = index;
                this.status.textContent = `${this.currentMatchIndex + 1} / ${matchPositionsData.length}`;
                this.updateMatchListHighlight();

                const matchPosition = matchPositionsData[index];
                if (matchPosition) {
                    this.vscode.postMessage({
                        type: 'getLogByIndex',
                        index: matchPosition.index,
                        contentHash: matchPosition.contentHash
                    });
                }
            }

            updateMatchListHighlight() {
                const matchItems = this.matchesDiv.querySelectorAll('div');
                matchItems.forEach((div, index) => {
                    this.updateMatchItemHighlight(div, index);
                });
            }

            updateMatchListContent(fragments, matchPositionsData) {
                const matchItems = this.matchesDiv.querySelectorAll('div');
                const maxItems = Math.min(fragments.length, matchItems.length);

                for (let i = 0; i < maxItems; i++) {
                    const div = matchItems[i];
                    const fragment = fragments[i];
                    div.innerHTML = `<span style="cursor:pointer; color:#6cf;">[${i + 1}]</span> ${fragment.context}`;
                    this.updateMatchItemHighlight(div, i);

                    // 更新数据属性，用于事件委托
                    div.dataset.matchIndex = i;
                    div.dataset.logIndex = matchPositionsData[i].index;
                    div.dataset.contentHash = matchPositionsData[i].contentHash;
                }

                if (fragments.length !== matchItems.length) {
                    this.renderMatchList(fragments, matchPositionsData);
                }
            }

            highlightLogContent(query) {
                if (!query || this.matchPositions.length === 0) return;

                const regex = new RegExp(this.escapeRegExp(query), 'gi');
                this.log.innerHTML = '';

                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);
                    const processedLine = this.processLogLine(line);
                    const highlightedLine = this.escapeHTML(processedLine).replace(regex, match => {
                        return `<span style="background: rgba(255, 255, 0, 0.5); color: black;">${this.escapeHTML(match)}</span>`;
                    });
                    lineDiv.innerHTML = highlightedLine;
                    this.log.appendChild(lineDiv);
                });
            }

            highlightTargetLine(targetLineIndex) {
                if (targetLineIndex < 0 || targetLineIndex >= this.currentLogLines.length) return;

                const targetLine = this.currentLogLines[targetLineIndex];
                if (!targetLine) return;

                this.log.innerHTML = '';

                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);

                    if (index === targetLineIndex) {
                        lineDiv.id = 'here';
                        lineDiv.style.background = 'linear-gradient(90deg, rgba(255, 255, 0, 0.4), rgba(255, 255, 0, 0.2))';
                        lineDiv.style.borderLeft = '4px solid #ffeb3b';
                        lineDiv.style.padding = '2px 4px';
                        lineDiv.style.margin = '1px 0';
                        lineDiv.style.boxShadow = '0 0 8px rgba(255, 255, 0, 0.3)';
                    }

                    const processedLine = this.processLogLine(line);
                    lineDiv.textContent = processedLine;
                    this.log.appendChild(lineDiv);
                });

                this.scrollToTargetLine();
            }

            createLogLineDiv(index) {
                const lineDiv = document.createElement('div');
                lineDiv.className = 'log-line';
                lineDiv.dataset.lineIndex = index;
                lineDiv.style.whiteSpace = 'pre-wrap';
                lineDiv.style.wordBreak = 'break-all';
                
                // 添加双击事件监听器
                lineDiv.addEventListener('dblclick', (event) => {
                    this.handleLogLineDoubleClick(event, index);
                });
                
                return lineDiv;
            }

            scrollToTargetLine() {
                setTimeout(() => {
                    const targetDiv = this.log.querySelector('#here');
                    if (targetDiv) {
                        const targetOffsetTop = targetDiv.offsetTop;
                        this.log.scrollTop = targetOffsetTop - this.log.clientHeight / 2 + targetDiv.clientHeight / 2;
                    }
                }, 10);
            }

            renderLogLines() {
                const needScroll = this.isAtBottom();
                if (!needScroll) {
                    return;
                }
                this.log.innerHTML = '';
                this.currentLogLines.forEach((line, index) => {
                    const lineDiv = this.createLogLineDiv(index);
                    // 处理 JSON 中的 \n 字符，转换为实际换行
                    const processedLine = this.processLogLine(line);
                    lineDiv.textContent = processedLine;
                    this.log.appendChild(lineDiv);
                });
                if (needScroll) {
                    this.log.scrollTop = this.log.scrollHeight;
                }

                // 移除这里的快速搜索计数器更新，避免重复调用
                // 计数器更新已经在 handleLog 中处理
            }

            clearSearchHighlights() {
                this.matchPositions = [];
                this.currentMatchIndex = -1;
                this.status.textContent = '';
                this.matchesDiv.innerHTML = '';
                this.persistState();
            }

            showMatchesDiv() {
                this.matchesDiv.style.display = 'block';
            }

            hideMatchesDiv() {
                this.matchesDiv.style.display = 'none';
            }

            clearLog() {
                this.currentLogLines = [];
                this.log.innerHTML = '';

                // 重置所有快速搜索计数器
                Array.from(this.quickSearchKeywords).forEach(keyword => {
                    this.quickSearchCounts.set(keyword, 0);
                });
                this.updateQuickSearchCounts();

                this.vscode.postMessage({ type: 'clearLog' });
            }

            sendSearchRequest() {
                this.vscode.postMessage({
                    type: 'searchLog',
                    query: this.search.value.trim(),
                });
            }

            escapeHTML(str) {
                return str.replace(/[&<>"']/g, s => ({
                    '&': '&amp;', '<': '&lt;', '>': '&gt;', '"': '&quot;', "'": '&#039;'
                }[s]));
            }

            restoreState() {
                const cached = this.vscode.getState();
                if (cached) {
                    if (cached.searchText) this.search.value = cached.searchText;
                    if (cached.matchIndex !== undefined) this.currentMatchIndex = cached.matchIndex;
                }
            }

            requestInitialState() {
                this.vscode.postMessage({ type: 'getStateRequest' });
            }

            requestHistory() {
                this.vscode.postMessage({ type: 'getHistoryRequest' });
            }

            persistState() {
                this.vscode.setState({
                    searchText: this.search.value.trim(),
                    matchIndex: this.currentMatchIndex,
                    scrollTop: this.log.scrollTop,
                });
                this.vscode.postMessage({
                    type: 'updatePanelState',
                    payload: {
                        searchText: this.search.value.trim(),
                        matchIndex: this.currentMatchIndex,
                        scrollTop: this.log.scrollTop,
                    }
                });
            }

            // 处理日志行中的转义字符
            processLogLine(line) {
                if (!line) return line;

                // 处理常见的转义字符
                return line
                    .replace(/\\n/g, '\n')        // \n -> 换行
                    .replace(/\\t/g, '\t')        // \t -> 制表符
                    .replace(/\\r/g, '\r')        // \r -> 回车
                    .replace(/\\"/g, '"')         // \" -> 双引号
                    .replace(/\\'/g, "'")         // \' -> 单引号
                    .replace(/\\\\/g, '\\');      // \\ -> 反斜杠
            }

            // 判断是否在底部（精确判断）
            isAtBottom() {
                const threshold = 1; // 允许1像素的误差
                return Math.abs(this.log.scrollTop + this.log.clientHeight - this.log.scrollHeight) <= threshold;
            }

            // 更新快速搜索计数器
            updateQuickSearchCounts() {
                // 批量更新，避免频繁DOM操作
                const updates = [];
                
                this.quickSearchCounts.forEach((count, keyword) => {
                    const countSpan = document.getElementById(`count_${keyword}`);
                    if (countSpan) {
                        updates.push({ element: countSpan, count: count.toString() });
                    }
                });
                
                // 使用 requestAnimationFrame 批量更新DOM
                if (updates.length > 0) {
                    requestAnimationFrame(() => {
                        updates.forEach(({ element, count }) => {
                            if (element.textContent !== count) {
                                element.textContent = count;
                            }
                        });
                    });
                }
            }

            // 检查并更新快速搜索计数
            checkAndUpdateQuickSearchCounts() {
                // 在初始化完成前，不执行本地计算
                if (!this._isInitialized) {
                    return;
                }

                // 防抖：避免短时间内重复调用
                if (this._quickSearchUpdateTimer) {
                    clearTimeout(this._quickSearchUpdateTimer);
                }

                this._quickSearchUpdateTimer = setTimeout(() => {
                    this._performQuickSearchUpdate();
                }, 200); // 增加防抖时间到200ms
            }

            // 处理日志行双击事件
            handleLogLineDoubleClick(event, lineIndex) {
                const line = this.currentLogLines[lineIndex];
                if (!line) {
                    console.error('双击事件: 未找到行内容, lineIndex:', lineIndex);
                    return;
                }
                
                // 获取点击位置相对于当前行的偏移
                const lineDiv = event.currentTarget;
                const rect = lineDiv.getBoundingClientRect();
                const clickY = event.clientY - rect.top;
                
                // 计算点击的是该日志行中的第几行
                const lineHeight = this.getLineHeight();
                const clickedLineIndex = Math.max(0, Math.floor(clickY / lineHeight));
                
                // 调试信息
                console.log('=== 双击事件信息 ===');
                console.log('双击事件信息:', {
                    lineIndex,
                    clickY,
                    lineHeight,
                    clickedLineIndex,
                    totalLines: lineDiv.textContent.split('\n').length,
                    originalLine: line.substring(0, 200) + '...',
                    displayText: lineDiv.textContent.substring(0, 200) + '...'
                });
                
                // 解析日志中的文件名和行号，考虑多行情况
                const fileInfo = this.parseLogLineForFileInfo(line, clickedLineIndex);
                if (fileInfo) {
                    console.log('=== 解析成功 ===');
                    console.log('解析到的文件信息:', fileInfo);
                    // 发送跳转请求到后端
                    this.vscode.postMessage({
                        type: 'jumpToFile',
                        payload: fileInfo
                    });
                } else {
                    console.log('=== 解析失败 ===');
                    console.log('未找到文件信息');
                    
                    // 尝试在显示文本中查找文件信息
                    console.log('尝试在显示文本中查找...');
                    const displayFileInfo = this.parseLogLineForFileInfo(lineDiv.textContent, clickedLineIndex);
                    if (displayFileInfo) {
                        console.log('在显示文本中找到文件信息:', displayFileInfo);
                        this.vscode.postMessage({
                            type: 'jumpToFile',
                            payload: displayFileInfo
                        });
                    } else {
                        console.log('显示文本中也没有找到文件信息');
                    }
                }
                console.log('==================');
            }
            
            // 获取行高
            getLineHeight() {
                // 创建一个临时元素来测量行高
                const tempDiv = document.createElement('div');
                tempDiv.style.fontSize = window.getComputedStyle(this.log).fontSize;
                tempDiv.style.fontFamily = window.getComputedStyle(this.log).fontFamily;
                tempDiv.style.lineHeight = 'normal';
                tempDiv.textContent = 'A';
                document.body.appendChild(tempDiv);
                const lineHeight = tempDiv.offsetHeight;
                document.body.removeChild(tempDiv);
                return lineHeight;
            }
            
            // 解析日志行中的文件信息，支持多行情况
            parseLogLineForFileInfo(line, clickedLineIndex = 0) {
                // 处理转义字符，但保留原始字符串用于解析
                const processedLine = this.processLogLine(line);
                
                console.log('=== 开始解析文件信息 ===');
                console.log('原始行:', line);
                console.log('点击行索引:', clickedLineIndex);
                console.log('处理后的行:', processedLine);
                
                // 模式2: File "path/to/file.py", line 1277 (支持多行，包含可选的 in function_name) - 优先处理
                const pattern2 = /File\s+"([^"]+\.py)",\s*line\s+(\d+)(?:\s+in\s+(\w+))?/;
                
                // 在原始行中查找所有匹配项
                const matches = [];
                let match;
                const regex = new RegExp(pattern2, 'g');
                
                while ((match = regex.exec(line)) !== null) {
                    const filePath = match[1];
                    const lineNumber = parseInt(match[2]);
                    const functionName = match[3] || null;
                    
                    if (!isNaN(lineNumber)) {
                        // 计算这个匹配项在转义后的文本中对应的行数
                        const beforeMatch = line.substring(0, match.index);
                        const processedBefore = this.processLogLine(beforeMatch);
                        const lineCount = (processedBefore.match(/\n/g) || []).length;
                        
                        matches.push({
                            filePath,
                            lineNumber,
                            functionName,
                            lineCount,
                            matchIndex: match.index,
                            originalIndex: match.index
                        });
                        
                        console.log(`找到模式2匹配:`, {
                            filePath,
                            lineNumber,
                            functionName,
                            lineCount,
                            matchIndex: match.index
                        });
                    }
                }
                
                // 调试信息
                console.log('文件信息匹配结果:', {
                    clickedLineIndex,
                    totalProcessedLines: processedLine.split('\n').length,
                    matches: matches.map(m => ({
                        filePath: m.filePath,
                        lineNumber: m.lineNumber,
                        functionName: m.functionName,
                        lineCount: m.lineCount
                    }))
                });
                
                // 根据点击的行索引找到对应的文件信息
                if (matches.length > 0) {
                    // 找到点击行对应的文件信息
                    for (let i = 0; i < matches.length; i++) {
                        const match = matches[i];
                        const nextMatch = matches[i + 1];
                        
                        // 计算这个匹配项对应的行范围
                        const startLine = match.lineCount;
                        const endLine = nextMatch ? nextMatch.lineCount : startLine + 1;
                        
                        console.log(`检查匹配项 ${i}:`, {
                            filePath: match.filePath,
                            lineNumber: match.lineNumber,
                            functionName: match.functionName,
                            startLine,
                            endLine,
                            clickedLineIndex,
                            isInRange: clickedLineIndex >= startLine && clickedLineIndex < endLine
                        });
                        
                        if (clickedLineIndex >= startLine && clickedLineIndex < endLine) {
                            const fileName = match.filePath.split(/[\\\/]/).pop();
                            console.log('找到匹配的文件信息:', {
                                fileName,
                                lineNumber: match.lineNumber,
                                functionName: match.functionName,
                                fullPath: match.filePath,
                                clickedLineIndex,
                                startLine,
                                endLine
                            });
                            return { 
                                fileName, 
                                lineNumber: match.lineNumber, 
                                fullPath: match.filePath,
                                functionName: match.functionName
                            };
                        }
                    }
                    
                    // 如果点击的行超出范围，返回最后一个匹配项
                    const lastMatch = matches[matches.length - 1];
                    const fileName = lastMatch.filePath.split(/[\\\/]/).pop();
                    console.log('使用最后一个匹配项:', {
                        fileName,
                        lineNumber: lastMatch.lineNumber,
                        functionName: lastMatch.functionName,
                        fullPath: lastMatch.filePath
                    });
                    return { 
                        fileName, 
                        lineNumber: lastMatch.lineNumber, 
                        fullPath: lastMatch.filePath,
                        functionName: lastMatch.functionName
                    };
                }
                
                // 如果没有找到 File "path.py", line 123 格式的匹配，且点击的是第一行，才使用模式1
                if (clickedLineIndex === 0) {
                    // 模式1: ProcessBase.py65 - 文件名.py行号
                    const pattern1 = /(\w+\.py\d+)/;
                    const match1 = line.match(pattern1);
                    if (match1) {
                        const fullMatch = match1[1];
                        const dotIndex = fullMatch.lastIndexOf('.');
                        if (dotIndex > 0) {
                            const fileName = fullMatch.substring(0, dotIndex + 3); // 包含.py
                            const lineNumber = parseInt(fullMatch.substring(dotIndex + 3));
                            if (!isNaN(lineNumber)) {
                                console.log('使用模式1匹配:', { fileName, lineNumber });
                                return { fileName, lineNumber };
                            }
                        }
                    }
                }
                
                console.log('未找到任何文件信息');
                console.log('=== 解析结束 ===');
                return null;
            }

            // 实际执行快速搜索更新的方法
            _performQuickSearchUpdate() {
                // 不再重置计数器，而是增量更新
                // 这样可以避免计数器闪动
                
                // 检查当前日志缓冲区中的匹配
                // 注意：这里应该只计算新增的匹配，而不是重新计算全部
                // 由于后端已经处理了计数，前端主要负责显示更新
                
                // 如果后端没有提供计数，才进行本地计算
                if (this.quickSearchCounts.size === 0) {
                    this.currentLogLines.forEach(line => {
                        Array.from(this.quickSearchKeywords).forEach(keyword => {
                            if (line.toLowerCase().includes(keyword.toLowerCase())) {
                                const currentCount = this.quickSearchCounts.get(keyword) || 0;
                                this.quickSearchCounts.set(keyword, currentCount + 1);
                            }
                        });
                    });
                }

                this.updateQuickSearchCounts();
            }
        }

        // 初始化应用
        function initLogViewer() {
            try {
                new LogViewer();
            } catch (error) {
                console.error('Failed to initialize LogViewer:', error);
                // 显示错误信息
                document.body.innerHTML = `
                    <div style="padding: 20px; color: white; background: #1e1e1e; height: 100%;">
                        <h3>Log Viewer 初始化失败</h3>
                        <p>错误信息: ${error.message}</p>
                        <button onclick="location.reload()" style="padding: 8px 16px; margin-top: 10px;">
                            重新加载
                        </button>
                    </div>
                `;
            }
        }

        // 等待 DOM 完全加载后再初始化
        if (document.readyState === 'loading') {
            document.addEventListener('DOMContentLoaded', initLogViewer);
        } else {
            initLogViewer();
        }
    </script>
</body>

</html>